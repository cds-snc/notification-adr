# Current Manifests CI/CD 

Date: 2024-06-04

## Status

**DRAFT**.

## Related ADRs

For information on how manifest rollouts are done using GitHub ARC Runners please see this ADR:
[Private EKS Cluster](2024-02-15.private-eks-cluster.md)

## Context

The way the CI/CD works for releases to Kustomize is not well documented. This ADR outlines the **existing** Kustomize CI/CD process for staging and production. A second ADR will be created to propose changes to this process as we move toward leveraging helmfile for our releases.

## Staging

### Individual Application Rollouts

When deploying a new version of the application components (admin/api/document-download etc), the release to staging is kicked off at the application repository level when the docker image is built. The docker image tag is based on the first 7 digits of the github runner sha, and also tags this build as latest. The docker build and push workflow invokes a corresponding workflow in the notification-manifests repository passing the new docker tag to have it deployed to staging.

The manifests rollout workflow receives the new image tag and performs a manual patch of the existing deployment:
```shell
kubectl set image deployment.apps/api api=$DOCKER_SLUG:$DOCKER_TAG -n=notification-canada-ca 
```
#### Diagram

![Database activity stream architecture](./diagrams/2024-06-04.manifests-current-cicd/staging-cicd.png)

### Global Manifests Rollouts

When a global manifests rollout is performed by the merge to main (staging) github workflow, all of the Kustomize code is deployed.

```shell
notification-manifests/env/staging kubectl apply -k .
```



## Production

### Individual Application Rollouts

This concept does not exist for production. We only rollout all of Kustomize.

### Global Manifests Rollouts

Every night, the Notify PR Bot reads the latest github sha's for each repository, and if they've changed, creates a pull request that changes the values in the Kustomization.yaml for production. Once this is merged, all of the kustomize code is deployed at once.

Since the PR bot does not touch the helmfile side of things, we do a single global apply on helmfile with "latest" tags. 

### Diagram

![Database activity stream architecture](./diagrams/2024-06-04.manifests-current-cicd/production-cicd.png)

## Problems

### Kustomize

Because we do not actually update any manifests code when doing an individual application rollout, we lose all context of which version we should be using when we do a global manifest rollout with merge to main (staging). To overcome this, the staging Kustomize code is set to always use the "latest" tag. This means when we apply kustomize the explicitly versioned docker tag is overwritten with "latest". This works because the docker build and push job for each application tags as both latest and the github sha. It is however not ideal since it becomes difficult to track versions in staging, and also creates a delta between how staging and production releases are handled through release pipelines.


### Helmfile
For helmfile releases, we are relying on the helmfile logic to set the image versions in the overrides. For example, we may have something like the below example, which hard codes the tag for production, but accepts either an environment variable or will default to "latest" if it does not exist.

```yaml
      {{ if eq .Environment.Name "production" }}
      image:
        tag: release1.24
      {{ else }}
      image: 
        tag: {{ env "DOCKER_TAG" | default "latest" }}
      {{ end }}
```

This is an ok solution, but it's not ideal to have to modify the individual override files to set image versions for production manually. It would be ideal to have this done automatically like with the PR bot.

## Future

A second ADR will be forthcoming with proposed changes as we migrate towards helmfile.